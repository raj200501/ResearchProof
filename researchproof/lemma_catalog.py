"""Catalog of lemmas available to the proof checker."""

from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class Lemma:
    name: str
    signature: str
    description: str


LEMMA_CATALOG: List[Lemma] = [
    Lemma("plusZeroRight", "(n : Nat) -> plus n Z = n", "Right identity of addition."),
    Lemma("plusZeroLeft", "(n : Nat) -> plus Z n = n", "Left identity of addition."),
    Lemma("plusSuccRight", "(n : Nat) -> (m : Nat) -> plus n (S m) = S (plus n m)", "Addition over successor."),
    Lemma("plusSuccLeft", "(n : Nat) -> (m : Nat) -> plus (S n) m = S (plus n m)", "Addition with successor on the left."),
    Lemma("plusAssoc", "(x : Nat) -> (y : Nat) -> (z : Nat) -> plus (plus x y) z = plus x (plus y z)", "Associativity of addition."),
    Lemma("plusComm", "(x : Nat) -> (y : Nat) -> plus x y = plus y x", "Commutativity of addition."),
    Lemma("multZeroRight", "(n : Nat) -> mult n Z = Z", "Right annihilator of multiplication."),
    Lemma("multZeroLeft", "(n : Nat) -> mult Z n = Z", "Left annihilator of multiplication."),
    Lemma("multOneRight", "(n : Nat) -> mult n (S Z) = n", "Right identity of multiplication."),
    Lemma("multOneLeft", "(n : Nat) -> mult (S Z) n = n", "Left identity of multiplication."),
    Lemma("multSuccLeft", "(n : Nat) -> (m : Nat) -> mult (S n) m = plus m (mult n m)", "Multiplication by successor."),
    Lemma("multDistribLeft", "(x : Nat) -> (y : Nat) -> (z : Nat) -> mult x (plus y z) = plus (mult x y) (mult x z)", "Left distributivity of multiplication."),
    Lemma("multAssoc", "(x : Nat) -> (y : Nat) -> (z : Nat) -> mult (mult x y) z = mult x (mult y z)", "Associativity of multiplication."),
    Lemma("powZero", "(n : Nat) -> pow n Z = S Z", "Exponentiation by zero."),
    Lemma("powSucc", "(n : Nat) -> (m : Nat) -> pow n (S m) = mult n (pow n m)", "Exponentiation by successor."),
    Lemma("powOne", "(n : Nat) -> pow n (S Z) = n", "Exponentiation by one."),
    Lemma("powTwo", "(n : Nat) -> pow n (S (S Z)) = mult n n", "Square definition."),
    Lemma("doubleIsPlus", "(n : Nat) -> double n = plus n n", "Double as repeated addition."),
    Lemma("plusWithPred", "(n : Nat) -> plus (pred n) (S Z) = n", "Predecessor is left-inverse of succ."),
    Lemma("predIsLeftInverse", "(n : Nat) -> pred (S n) = n", "Predecessor of successor."),
    Lemma("isZeroFalse", "(n : Nat) -> isZero (S n) = False", "Successor is not zero."),
    Lemma("isZeroTrue", "isZero Z = True", "Zero is zero."),
    Lemma("plusSelfSucc", "(n : Nat) -> plus n (S n) = S (plus n n)", "Self successor addition."),
    Lemma("plusSwap", "(x : Nat) -> (y : Nat) -> plus x (S y) = plus (S x) y", "Swap successor in addition."),
    Lemma("doubleSucc", "(n : Nat) -> double (S n) = S (S (double n))", "Double of successor."),
    Lemma("andTrueLeft", "(b : Bool) -> and True b = b", "And with true on the left."),
    Lemma("andTrueRight", "(b : Bool) -> and b True = b", "And with true on the right."),
    Lemma("andFalseLeft", "(b : Bool) -> and False b = False", "And with false on the left."),
    Lemma("andFalseRight", "(b : Bool) -> and b False = False", "And with false on the right."),
    Lemma("orTrueLeft", "(b : Bool) -> or True b = True", "Or with true on the left."),
    Lemma("orTrueRight", "(b : Bool) -> or b True = True", "Or with true on the right."),
    Lemma("orFalseLeft", "(b : Bool) -> or False b = b", "Or with false on the left."),
    Lemma("orFalseRight", "(b : Bool) -> or b False = b", "Or with false on the right."),
    Lemma("notInvolutive", "(b : Bool) -> not (not b) = b", "Double negation."),
    Lemma("xorComm", "(a : Bool) -> (b : Bool) -> xor a b = xor b a", "Xor commutativity."),
    Lemma("xorFalseLeft", "(b : Bool) -> xor False b = b", "Xor with false (left)."),
    Lemma("xorFalseRight", "(b : Bool) -> xor b False = b", "Xor with false (right)."),
    Lemma("xorTrueLeft", "(b : Bool) -> xor True b = not b", "Xor with true (left)."),
    Lemma("xorTrueRight", "(b : Bool) -> xor b True = not b", "Xor with true (right)."),
    Lemma("notAnd", "(a : Bool) -> (b : Bool) -> not (and a b) = or (not a) (not b)", "De Morgan (and)."),
    Lemma("notOr", "(a : Bool) -> (b : Bool) -> not (or a b) = and (not a) (not b)", "De Morgan (or)."),
    Lemma("appendNilRight", "(xs : List Nat) -> append xs Nil = xs", "Right identity for append."),
    Lemma("appendNilLeft", "(xs : List Nat) -> append Nil xs = xs", "Left identity for append."),
    Lemma("appendAssoc", "(xs : List Nat) -> (ys : List Nat) -> (zs : List Nat) -> append (append xs ys) zs = append xs (append ys zs)", "Associativity of append."),
    Lemma("lengthAppend", "(xs : List Nat) -> (ys : List Nat) -> length (append xs ys) = plus (length xs) (length ys)", "Length of append."),
    Lemma("lengthSnoc", "(xs : List Nat) -> (x : Nat) -> length (snoc xs x) = S (length xs)", "Length of snoc."),
    Lemma("lengthReplicate", "(n : Nat) -> (x : Nat) -> length (replicate n x) = n", "Length of replicate."),
    Lemma("mapIdentity", "(xs : List Nat) -> map (\\x => x) xs = xs", "Map identity."),
    Lemma("mapCompose", "(f : Nat -> Nat) -> (g : Nat -> Nat) -> (xs : List Nat) -> map f (map g xs) = map (\\x => f (g x)) xs", "Map composition."),
    Lemma("reverseAppend", "(xs : List Nat) -> (ys : List Nat) -> reverse (append xs ys) = append (reverse ys) (reverse xs)", "Reverse append."),
    Lemma("reverseInvolutive", "(xs : List Nat) -> reverse (reverse xs) = xs", "Reverse is involutive."),
    Lemma("foldrAppend", "(f : Nat -> Nat -> Nat) -> (acc : Nat) -> (xs : List Nat) -> (ys : List Nat) -> foldr f acc (append xs ys) = foldr f (foldr f acc ys) xs", "Foldr append."),
    Lemma("andComm", "And a b -> And b a", "Commutativity of And."),
    Lemma("andAssoc", "And (And a b) c -> And a (And b c)", "Associativity of And."),
    Lemma("andAssocInv", "And a (And b c) -> And (And a b) c", "Inverse associativity of And."),
    Lemma("orComm", "Or a b -> Or b a", "Commutativity of Or."),
    Lemma("orAssoc", "Or (Or a b) c -> Or a (Or b c)", "Associativity of Or."),
    Lemma("orAssocInv", "Or a (Or b c) -> Or (Or a b) c", "Inverse associativity of Or."),
    Lemma("andDistributesOverOr", "And a (Or b c) -> Or (And a b) (And a c)", "And distributes over Or."),
    Lemma("orDistributesOverAnd", "Or a (And b c) -> And (Or a b) (Or a c)", "Or distributes over And."),
    Lemma("iffRefl", "Iff a a", "Iff reflexivity."),
    Lemma("iffSym", "Iff a b -> Iff b a", "Iff symmetry."),
    Lemma("iffTrans", "Iff a b -> Iff b c -> Iff a c", "Iff transitivity."),
    Lemma("leqRefl", "(n : Nat) -> leq n n = True", "Reflexivity of leq."),
    Lemma("leqZeroLeft", "(n : Nat) -> leq Z n = True", "Zero is <= n."),
    Lemma("leqZeroRight", "(n : Nat) -> leq n Z = isZero n", "Zero right comparison."),
    Lemma("minComm", "(x : Nat) -> (y : Nat) -> min x y = min y x", "Commutativity of min."),
    Lemma("maxComm", "(x : Nat) -> (y : Nat) -> max x y = max y x", "Commutativity of max."),
    Lemma("subZeroRight", "(n : Nat) -> sub n Z = n", "Subtracting zero."),
    Lemma("subSelf", "(n : Nat) -> sub n n = Z", "Subtracting self."),
    Lemma("evenDouble", "(n : Nat) -> even (double n) = True", "Evenness of double."),
    Lemma("oddSucc", "(n : Nat) -> odd (S n) = not (odd n)", "Odd successor."),
]
